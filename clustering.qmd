---
title: "Clustering"
author: "Ángel García, Arnau Piferrer y Guillem Serra"
format: html
editor: visual
---

Este es el [repositorio](https://github.com/GSMir/Entrega3) de GitHub en el que alojaremos todos los archivos relacionados con esta entrega. Para consultar la fuente de la que se ha extraído nuestro Dataset consulta el siguiente [link](https://archive.ics.uci.edu/dataset/45/heart+disease). Nuestro Dataset ha sido publicado por la Universidad de California de Irvine.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r, message = FALSE,warning=FALSE}
library(readr)
library(tidyverse)
library(dplyr)
library(patchwork)
library(MVA)
library(corrplot)
library(graphics)
library(GGally)
library("aplpack")
library(ggplot2)
library(factoextra)
library(cluster)
```

```{r}
heartdisease <- read_csv("https://archive.ics.uci.edu/ml/machine-learning-databases/heart-disease/processed.cleveland.data", col_names = FALSE, show_col_types = FALSE) %>%
  filter(!str_detect(X13, "\\?"), !str_detect(X12, "\\?")) %>%
  mutate(across(c(X2, X3, X6, X7, X9, X11), as.factor), 
         tHR2 = case_when(
           X13 == "3.0" ~ "3",
           X13 == "6.0" ~ "6",
           X13 == "7.0" ~ "7"),
         fdiag2 = case_when(
           X14 %in% 0:4 ~ as.character(X14 %>% as.numeric() > 0)),
         across(c(tHR2, fdiag2), as.factor),
         age = X1, restbp = X4, chol = X5, maxHR = X8, expeak = X10) %>%
  select(age, sex = X2, cp = X3, restbp, chol, fbs = X6, restecg = X7, 
         maxHR = X8, exang = X9, expeak, slope = X11, tHR = tHR2, fdiag = fdiag2) %>%
  arrange(age, sex) %>% # Asumiendo que tu dataframe se llama heartdisease y que tiene una columna age
  mutate(grupo_edad = factor(case_when(
    age >= 29 & age <= 45 ~ "joven",
    age >= 46 & age <= 59 ~ "maduro",
    age >= 60 & age <= 77 ~ "mayor",
    TRUE ~ NA_character_  # Para cualquier edad fuera de los rangos especificados
  ))) %>%
  select(grupo_edad, everything())


heartdisease_numeric <- heartdisease %>%
  select(where(is.numeric)) %>%
  scale()


heartdisease_categoric <- heartdisease %>%
  select(where(is.factor))
```

```{r}
mat_dist <- dist(x = heartdisease_numeric, method = "euclidean")
#round(as.matrix(mat_dist)[1:9, 1:9], 2)
```

```{r}
mat_dist <- get_dist(x = heartdisease_numeric, method = "pearson")
#round(as.matrix(mat_dist)[1:9, 1:9], 2)
#fviz_dist(dist.obj = mat_dist, lab_size = 5) +
#theme(legend.position = "right") #Heatmap de matrices de distancia
```

```{r}
set.seed(420) # Para reproducibilidad
datos <- heartdisease_numeric[, c("restbp", "chol")]

wcss <- sapply(1:10, function(k) {
  kmeans(datos, centers = k, nstart = 50)$tot.withinss
})

plot(1:10, wcss, type = "b", xlab = "Número de Clusters", ylab = "Suma de Cuadrados Dentro del Grupo (WCSS)", main = "Método del Codo")
```

```{r}
sil_width <- numeric(length(2:10)) # Pre-allocate the vector to ensure it has the correct length

for (k in 2:10) {
  km_res <- kmeans(as.data.frame(datos), centers = k, nstart = 50)
  sil <- silhouette(km_res$cluster, dist(as.data.frame(datos)))
  
  if (length(sil[, 3]) == length(km_res$cluster)) {
    sil_width[k-1] <- mean(sil[, 3])
  } else {
    sil_width[k-1] <- NA # Assign NA if the result is not as expected
  }
}

# Remove NA values in case there were any errors
valid_indices <- !is.na(sil_width)
plot(2:10, sil_width, type = "b", xlab = "Número de Clusters", ylab = "Ancho Promedio de Silueta", main = "Análisis de Silueta")
```

```{r}

# Suponiendo que heartdisease_numeric ya está cargado y que eliges dos columnas específicas
# Por ejemplo, 'restbp' y 'chol'
datos <- heartdisease_numeric[, c("restbp", "chol")]
grupo <- heartdisease$grupo_edad

km_clusters <- kmeans(x = datos, centers = 3, nstart = 50)
#km_clusters

datos <- cbind(datos, grupo)
```

```{r}
datos <- cbind(cluster = km_clusters$cluster, datos) 
plot(x = datos[,"restbp"], y = datos[,"chol"], col = km_clusters$cluster, pch = 1,
     cex = 2, lwd = 2, xlab = "restbp", ylab = "chol") 
# Se rellenan las circunferencias con puntos del color real del grupo al 
# que pertenecen las observaciones. Es necesario hacer coincidir los 
# colores con el mismo orden que el devuelto por la función kmeans() ya 
# que el clustering no asigna variable respuesta, solo agrupa las 
# observaciones. 
points(x = datos[,"restbp"], y = datos[,"chol"], 
       col = c(2, 1, 3, 4)[datos[, "grupo"]], pch = 19)
```

```{r}
table(km_clusters$cluster, datos[, "grupo"], 
      dnn = list("cluster", "grupo real"))
```

```{r}
heartdisease$cluster <- km_clusters$cluster

ggplot(heartdisease, aes(x = factor(cluster), fill = grupo_edad)) +
  geom_bar(position = "dodge") +
  labs(x = "Cluster", y = "Count", fill = "Grupo de Edad") +
  theme_minimal()
```
